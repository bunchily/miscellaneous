#!/usr/bin/ksh
#===============================================================================
#@(#) Unix Shell Script:	ora_DB_verify
#
#
#@(#) Purpose: To run Oracle dbv on all datafiles utilized by a database 
#@(#)
# 
#@(#) Usage: ora_DB_verify <database...database>		
#
# Where: <database> is an oracle database on the local system
#
# Notes:
#	1. Clears previous master log and trace files.
#	2. Oracle environment is set up & database passed is checked for
#	   "OPEN" status. If not open, an error is generated & exit 1
#	3. Temporary SQL is build to access v$datafile for the database passed.
#	4. Information from v$datafile is extracted & used to build a dbv
#	   command line which is then executed.
#	5. The logfile generated by dbv is searched for messages indicating
#	   corrupt blocks. If corruption is found and error is generated.
#	6. Logfile generated by dbv is appended to the master log.
#	7. Steps 4-6 are repeated until all datafiles found in v$datafiles
#	   have been checked.
#	8. Temporary logs & SQL files are cleaned up.
#	9. If errors have been encountered then exit 2.
#	
#	TESTING PROCEDURE:
#	To create a datafile with corrupt blocks for testing etc use the 
#	following command line.
#dd of=<output> if=<input> bs=<block size> conv=notrunc seek=<block> <<EOF
#CORRUPT ME
#EOF
#	where 
#   	<output> is the new file to output corrupted data to
#	<input> is the original datafile
#	<block size> is the size of the oracle blocks, see v$datafile for info
#	<block> is the block you want to corrupt
#	the here document "<<EOF" is the data that gets written to the block
#	to corrupt it.
#	SEE man dd for further information.
#
#	To identify a block to corrupt use the following sql:
#	Select block_id fro DBA_EXTENTS where SEGMENT_NAME = '<table name>'
#	
#	After corruption test with the following sql:
#	Select * from <table name>
#	
#	An oracle error should be generated specifying the block id that has 
#	been corrupted.
#	
#
#@(#) External Functions : data_base_status, xfn_lg Message, xfn_utl_mail,
#	xfn_lg_Transaction_break, xfn_lg_Job_Monitor, xfn_ora_Set_DB_Env,
#	xfn_ora_Execute_SQL_Script
#
#@(#) Author:	Cary Corse	DD-MM-YY
#
# Checked By:	Name		DD-MM-YY
#
#@(#) Version:	1.0
#===============================================================================
#
# History of Changes:
#
# 1.0	CAC	16-03-05
#	Initial Release
# 1.1	CAC	18-04-05
#	Output from dbv is on std error, to prevent additional e-mails sent
#	by cron to executor std error now output  to std out 2>&1.
#
#
#-------------------------------------------------------------------------------

#===============================================================================
#	Declare Variables
#-------------------------------------------------------------------------------
PRG=$(basename ${0})			#Program name
ADDRESS=cary.corse@cumbriacc.gov.uk	#email address
DATAFILE= 				#list of datafiles from v$datafiles
DATAFILES=				#single datafile from $DATAFILES
FPATH=$FPATH:/opt/local/functions/oracle:/opt/local/functions/log:/opt/local/functions/utils
PATH=/opt/local/sbin:/opt/local/bin:/usr/bin
PASSWORD=				#password set by xfn_ora_Set_DB_Env 
TEXT=					#Error message text
USAGE=					#Usage message
USER=system				#Database user
#===============================================================================
#	Functions Start Here
#-------------------------------------------------------------------------------
#===============================================================================
#       Function to build temporary SQL
#       Usage: fn_Build_SQL
#-------------------------------------------------------------------------------
fn_Build_SQL ()
{

cat > $TMP_SQL <<- EOF
	set linesize 2000;
	select 'DATAFILE',name ,block_size from v\$datafile;
	EOF

}


#===============================================================================
#       Function to Display Usage message
#       Usage: fn_Usage
#-------------------------------------------------------------------------------
fn_Usage ()
{

USAGE="Usage: ${PRG} <database...database>" 

echo $USAGE 1>&2
exit 3

}


#===============================================================================
#       Function to Mail utsg on error
#       Usage: fn_Error <Y|N> <text> <file>
#-------------------------------------------------------------------------------
fn_Error ()
{
CONTINUE=${1}
TEXT=${2}
ATTATCH=${3}

echo "$TEXT" 1>&2

# If attatchment is specified then attatch to email
if [ ${ATTATCH} ]
then
  xfn_utl_mail -a ${ADDRESS} -s "ERROR: ora_DB_verify: ($DATABASE)@`hostname`" \
      -t"${TEXT}" -f${ATTATCH}
else
  xfn_utl_mail -a ${ADDRESS} -s "ERROR: ora_DB_verify: ($DATABASE)@`hostname`" \
      -t"${TEXT}" 
fi

# Update Job Monitor Log
xfn_lg_Job_Monitor -e

# set exit code depending on type of error,Terminal error=1, non terminal=2
if [[ ${CONTINUE} == N ]]
then
   EXIT_CODE=1
   fn_Finish
else
   EXIT_CODE=2
fi

}


#===============================================================================
#       Function to clean up temp file
#       Usage: fn_Finish
#-------------------------------------------------------------------------------
fn_Finish ()
{

# Remove temporary SQL and logs
rm ${TMP_SQL}
rm ${LOG_DBV_TMP}
rm ${TRACE}

# if errors have been encountered then exit with appropriate code.
if [ ${EXIT_CODE} ]
then
   exit ${EXIT_CODE} 
fi
# Insert transaction breaks 
xfn_lg_Transaction_Break ${LOG}

# Update Job Monitor log
xfn_lg_Job_Monitor -c
}


#^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#	Main Processing Starts Here
#-------------------------------------------------------------------------------
DATABASES=$*

for DATABASE in ${DATABASES}
do

LOG_DBV_TMP=/tmp/dbv_tmp_${DATABASE}.log	#log generated by dbv per datafile
LOG_DBV=/opt/spool/log/alert/oracle/dbv_${DATABASE}.log	#cat'd dbv logs for this run
LOG=/opt/spool/log/alert/oracle/${PRG}_${DATABASE}.log	#Benchmark log for timestamp 
TMP_SQL="/tmp/temp_${DATABASE}$$.sql"		#temporary sql statments
TRACE=/tmp/trace_${DATABASE}.tmp			#SQL trace file

# null out previous log and trace files
>${LOG_DBV}

# Check usage
if [[ ${DATABASE} == "-?" ]]
then
  fn_Usage
fi

if [[ $# -eq 0 ]]
then
   fn_Usage
fi

xfn_ora_Set_DB_Env -d${DATABASE} -u${USER}

# Update Job Monitor log
xfn_lg_Job_Monitor -t "Job Started (${USER}@${DATABASE})"

# is the database available
if ! /opt/local/sbin/data_base_status -d ${DATABASE} >/dev/null; then
   # No so abort run
   fn_Error N "Database ${DATABASE} is not available"
fi

# create temporary SQL file
fn_Build_SQL

# Use output from temporary SQL file to determine which .dbf files to work on.
xfn_ora_Execute_SQL_Script -s ${USER} ${PASSWORD} ${TMP_SQL} | tee -a ${TRACE} \
   | awk '/^DATAFILE/ {print $2,$3}' | sort -t "/" -k 2 | \
while read  DATAFILE BLOCKSIZE
do
   xfn_lg_Message ${LOG} "Start dbv on ${DATAFILE}"

   # run dbv on supplied datafile DBVERIFY is output on error so to prevent
   # additional e-mails output error on std output 2>&1
   dbv LOGFILE=${LOG_DBV_TMP} FILE=${DATAFILE} BLOCKSIZE=${BLOCKSIZE} >/dev/null 2>&1
   
   xfn_lg_Message ${LOG} "Stop dbv on ${DATAFILE}"

   # Search for Pages that have been "Marked Corrupt"
   # NOTE checking the exit code of dbv would be a preferable method to check
   # for outcome of dbv, however dbv does not return a non-zero exit code if
   # corruption is found or suspected.  This issue is currently with Oracle
   # under BUG number 4150604.  
   DBV_VAL=$(egrep "Marked Corrupt   : [^0]" ${LOG_DBV_TMP}| awk -F: '{print $2}')
   if [[ ! -z ${DBV_VAL} ]]
   then
      # if pages that have been "Marked Corrupt" are found then call fn_ERROR.
      fn_Error Y "\n\nDBV has failed on $(basename ${DATAFILE}) \nPlease see attatched log file." "${LOG_DBV_TMP}"
   fi

   cat ${LOG_DBV_TMP} >> ${LOG_DBV}
   xfn_lg_Transaction_Break ${LOG_DBV}
   echo "" >> ${LOG}
done

fn_Finish
done
